package org.apache.kafka.kafka.common.config;

import com.newrelic.api.agent.weaver.NewField;
import com.newrelic.api.agent.weaver.Weave;
import com.newrelic.api.agent.weaver.Weaver;
import com.nr.instrumentation.kafka.config.ConfigEmitter;
import org.apache.kafka.clients.CommonClientConfigs;
import org.apache.kafka.common.config.AbstractConfig;
import org.apache.kafka.common.config.ConfigDef;

import java.util.HashMap;
import java.util.Map;

/**
 * This is the integration point at which we identify configs that are attached to clients and register
 * them for {@link ConfigEmitter emission}. This is a bit clumsy but ended up being the easiest way to
 * produce a solution that would work across different versions of Kafka without requiring different builds of
 * this extension. Specifically, there's a natural place to do this in KafkaProducer/Consumer constructors,
 * but Weaving requires that all weaves correspond to existing signatures, meaning we'd need different builds
 * for those different versions. This would be slightly painful to organize, but also make the extension
 * more difficult to use in that you'd need to make sure you had the right version, and it would be really easy
 * to accidentally package an extension that wouldn't actually work, without it being noticed.
 *
 * <p>
 *
 * What we do instead is take advantage of those constructors making a habit of calling config.logUnused() in the
 * final parts of construction. So we can weave in some magic to that method and look in the stack trace
 * to confirm it's during construction. If that's the case and can then consider this to be an actual client usage
 * of the config and we register it with the config emitter. In practice, there are likely to be very few
 * usages of logUnused() outside of construction.
 *
 * <p>
 *
 * If logUnused() stops being a regular part of construction then we'll obviously have to re-architect
 * this in some grosser fashion.
 */
@Weave(originalName = "org.apache.kafka.common.config.AbstractConfig")
public class AbstractConfig_Instrumentation {

    @NewField
    private static final Map<String, String> clientClassesToClientTypes = new HashMap<>();
    static {
        clientClassesToClientTypes.put("org.apache.kafka.clients.producer.KafkaProducer", "producer");

        final String consumer = "consumer";
        clientClassesToClientTypes.put("org.apache.kafka.clients.consumer.KafkaConsumer", consumer); // 0.9 (maybe?) -> 3.6.2
        // 3.7+ introduced a delegated consumer model, with the delegate class constructors
        // now being the ones calling logUnused()
        clientClassesToClientTypes.put("org.apache.kafka.clients.consumer.internals.LegacyKafkaConsumer", consumer); // 3.7 - 3.8
        clientClassesToClientTypes.put("org.apache.kafka.clients.consumer.internals.ClassicKafkaConsumer", consumer); // 3.9
        clientClassesToClientTypes.put("org.apache.kafka.clients.consumer.internals.AsyncKafkaConsumer", consumer); // 3.7+

        clientClassesToClientTypes.put("org.apache.kafka.clients.admin.AdminClient", "admin");
    }

    private final Map<String, ?> originals = Weaver.callOriginal();
    private final ConfigDef definition = Weaver.callOriginal();

    public void logUnused() {
        Weaver.callOriginal();
        final StackTraceElement[] elements = Thread.currentThread().getStackTrace();
        // We should only have to look back a couple of elements in the stack trace, so this shouldn't be
        // costly if someone's calling this outside of that context in a regular basis, but that seems unlikely
        for (int i = 0; i < 3 && i < elements.length; ++i) {
            if (elements[i].getMethodName().equals("<init>")) {
                final String clientType = clientClassesToClientTypes.get(elements[i].getClassName());
                if (clientType != null) {
                    // indicates we've been called by the client!
                    final String clientId;
                    final Object suppliedClientId = originals.get(CommonClientConfigs.CLIENT_ID_CONFIG);
                    if (!(suppliedClientId instanceof String) || ((String) suppliedClientId).isEmpty()) {
                        // indicates that there was no explicit clientId set during configuration.
                        // There will have been a specific clientId auto-generated by the client,
                        // but we don't have access to it (note that it is NOT what is in the config's
                        // effective settings, whose defaults will have provided a different client id).
                        //
                        // There'd be a way to sneak it out by introducing an interceptor into config, which would be
                        // configured with a map including clientId, but
                        // it's a bit clumsy, and ultimately, if the clientId is auto-generated then the
                        // config reporting for it's going to be unhelpful from an identification perspective.
                        // Hopefully the presence of unspecified clientIds in combination with other metadata can
                        // help identify the offending code without an explicit clientId, which is useful
                        // in itself.
                        //
                        // Tilde prefix is used to put such clients at the end of natural orderings
                        // and for easy exclusion when querying.
                        clientId = "~unspecified-" + clientType;
                    } else {
                        // explicit client ID which should respected by the constructor
                        clientId = (String) suppliedClientId;
                    }
                    // awkward casting to work around the fact that at weave time this will be AbstractConfig,
                    // but at compile time it's AbstractConfig_Instrumentation:
                    ConfigEmitter.get().registerConfiguration(clientId, (AbstractConfig) ((Object) this), definition);
                }
            }
        }
    }
}
